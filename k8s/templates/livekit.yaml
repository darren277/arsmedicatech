apiVersion: apps/v1
kind: Deployment
metadata:
  name: livekit
spec:
  replicas: 1
  selector:
    matchLabels:
      app: livekit
  template:
    metadata:
      labels:
        app: livekit
    spec:
      containers:
        - name: livekit
          image: livekit/livekit-server:v1.10
          #ports:
          #  - containerPort: 7880 # HTTP API
          #  - containerPort: 7881 # WebRTC TCP
          #  - containerPort: 3478 # TURN
          ports:
            - name: api
              containerPort: 7880
              hostPort: 7880
            - name: webrtc
              containerPort: 7881
              hostPort: 7881
            - name: turn-udp
              containerPort: 3478
              protocol: UDP
              hostPort: 3478
            # You need a hostPort for each UDP media port
            - name: rtp-50000
              containerPort: 50000
              protocol: UDP
              hostPort: 50000
            # ... and so on for every port in your range
            - name: rtp-50001
              containerPort: 50001
              protocol: UDP
              hostPort: 50001
            - name: rtp-50002
              containerPort: 50002
              protocol: UDP
              hostPort: 50002
            - name: rtp-50003
              containerPort: 50003
              protocol: UDP
              hostPort: 50003
            - name: rtp-50004
              containerPort: 50004
              protocol: UDP
              hostPort: 50004
            - name: rtp-50005
              containerPort: 50005
              protocol: UDP
              hostPort: 50005
            - name: rtp-50006
              containerPort: 50006
              protocol: UDP
              hostPort: 50006
            - name: rtp-50007
              containerPort: 50007
              protocol: UDP
              hostPort: 50007
            - name: rtp-50008
              containerPort: 50008
              protocol: UDP
              hostPort: 50008
            - name: rtp-50009
              containerPort: 50009
              protocol: UDP
              hostPort: 50009
            - name: rtp-50010
              containerPort: 50010
              protocol: UDP
              hostPort: 50010
          env:
            - name: LIVEKIT_REDIS_HOST
              value: {{ .Values.micro.livekit.redis.host }}
            - name: LIVEKIT_API_KEY
              valueFrom:
                secretKeyRef:
                  name: livekit-secrets
                  key: apiKey
            - name: LIVEKIT_API_SECRET
              valueFrom:
                secretKeyRef:
                  name: livekit-secrets
                  key: apiSecret
            - name: LIVEKIT_UDP_PORT_START
              value: "50000"
            - name: LIVEKIT_UDP_PORT_END
              value: "50010"
          #securityContext:
          #  privileged: true
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: livekit-config
data:
  livekit.yaml: |
    # The main HTTP/gRPC API port
    port: 7880
    log_level: info

    # CORS configuration to allow connections from your web app
    cors:
      allow_origins:
        - "*"

    # RTC (WebRTC) configuration
    rtc:
      # This MUST be the public IP address of the Kubernetes node or Load Balancer
      # that is exposed to the internet. LiveKit announces this IP to clients.
      # For cloud providers, you can often use 'use_external_ip: true' instead.
      node_ip: "YOUR_PUBLIC_IP_OR_HOSTNAME"
      tcp_port: 7881
      udp_port: 3478
      port_range_start: 50000
      port_range_end: 50010 # Using the 10 ports you requested

    # TURN (media relay) configuration
    turn:
      enabled: true
      udp_port: 3478
      # This domain MUST also point to the public IP of your node/load balancer.
      domain: "YOUR_PUBLIC_IP_OR_HOSTNAME"

    # Redis configuration, pointing to the Kubernetes service name
    redis:
      address: redis-livekit-service:6379
---
apiVersion: v1
kind: Secret
metadata:
  name: livekit-secrets
type: Opaque
stringData:
  apiKey: {{ .Values.micro.livekit.api.key }}
  apiSecret: {{ .Values.micro.livekit.api.secret }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: egress-config
data:
  egress.yaml: |
    api_key: {{ .Values.micro.livekit.api.key }}
    api_secret: {{ .Values.micro.livekit.api.secret }}
    ws_url: {{ .Values.micro.livekit.egress.wsUrl }}
    recording:
      file_outputs:
        - filepath: recordings/{{`{{ room_name }}`}}-{{`{{ timestamp }}`}}.mp4
          output:
            s3:
              access_key: {{ .Values.micro.livekit.s3.accessKey }}
              secret: {{ .Values.micro.livekit.s3.secretKey }}
              region: {{ .Values.micro.livekit.s3.region }}
              bucket: {{ .Values.micro.livekit.s3.bucket }}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: livekit-egress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: livekit-egress
  template:
    metadata:
      labels:
        app: livekit-egress
    spec:
      containers:
        - name: egress
          image: livekit/egress:v1.10
          volumeMounts:
            - name: egress-config
              mountPath: /egress.yaml
              subPath: egress.yaml
          env:
            - name: LIVEKIT_API_KEY
              valueFrom:
                secretKeyRef:
                  name: livekit-secrets
                  key: apiKey
            - name: LIVEKIT_API_SECRET
              valueFrom:
                secretKeyRef:
                  name: livekit-secrets
                  key: apiSecret
            - name: LIVEKIT_WS_URL
              value: {{ .Values.micro.livekit.egress.wsUrl }}
            - name: S3_ACCESS_KEY
              value: {{ .Values.micro.livekit.s3.accessKey }}
            - name: S3_SECRET_KEY
              value: {{ .Values.micro.livekit.s3.secretKey }}
            - name: S3_BUCKET
              value: {{ .Values.micro.livekit.s3.bucket }}
            - name: S3_REGION
              value: {{ .Values.micro.livekit.s3.region }}
          command: ["-config-file", "/egress.yaml"]
      volumes:
        - name: egress-config
          configMap:
            name: egress-config
---
apiVersion: v1
kind: Service
metadata:
  name: livekit
spec:
  type: NodePort  # or LoadBalancer for public
  ports:
    - port: 7880
      targetPort: 7880
      name: api
    - port: 7881
      targetPort: 7881
      name: webrtc
    - port: 3478
      targetPort: 3478
      protocol: UDP
      name: turn
  selector:
    app: livekit
---
apiVersion: v1
kind: Secret
metadata:
  name: flask-api-secrets
type: Opaque
stringData:
  s3Bucket: {{ .Values.micro.livekit.s3.bucket }}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: flask-api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: flask-api
  template:
    metadata:
      labels:
        app: flask-api
    spec:
      containers:
        - name: api
          # IMPORTANT: You must replace this with the actual name of the
          # Docker image you build and push to a container registry.
          image: "your-registry/your-flask-api-image:latest"
          ports:
            - containerPort: 5001
          env:
            # Pull LiveKit credentials from the existing secret
            - name: LIVEKIT_API_KEY
              valueFrom:
                secretKeyRef:
                  name: livekit-secrets
                  key: apiKey
            - name: LIVEKIT_API_SECRET
              valueFrom:
                secretKeyRef:
                  name: livekit-secrets
                  key: apiSecret
            # Pull the S3 bucket name from the new secret
            - name: LIVEKIT_S3_BUCKET
              valueFrom:
                secretKeyRef:
                  name: flask-api-secrets
                  key: s3Bucket
---
apiVersion: v1
kind: Service
metadata:
  name: flask-api-service
spec:
  # ClusterIP is suitable for internal communication.
  # Change to LoadBalancer if you need to expose this API publicly.
  type: ClusterIP
  selector:
    app: flask-api
  ports:
    - protocol: TCP
      port: 5001
      targetPort: 5001
